# Features

## Vapor (back-end)

This is our core project. It is tasked with interpreting a `daily.txt` transaction file which simulates the transaction of a store in a day. To utilize the backend please follow the instructions below.

Our project uses the external library (json-simple-1.1.jar) to create JSON files. Watch the following video tutorial to learn how to add (json-simple-1.1.jar) to the project.
    
[How to add json-simple-1.1.jar to project](https://www.youtube.com/watch?v=IdPTrxs7EzM)

### Major Design Decisions

*   For `User` construction, our group decided to use the Factory pattern as all users being made possess the same constructor parameters, with only the concrete child instance varying based on user type.

*   For `Transaction` construction, our group decided to use the Builder pattern as all transactions necessary data is comprised of a number of fields that may provide necessary information for that transaction or not. We decided to store all of this data in the base `Transaction` class to prevent code duplication (making members for the exact same elements for transactions of the same format) as any fields left uninitialised with data from the daily.txt file would not be accessed anyway.

*   For our `TransactionBuilder`, we also implemented used regex to ensure that the formats of fields we received matched those we were expecting, as well as used the transaction type codes of our transactions in a quasi-factory like structure to dispatch the appropriate transaction back to a caller, which is simply added to a shared container of transactions of differing types.

*   In numerous places, we used enumerated types to store various pieces of information and offer a convenient means to group, label, and iterate over elements. Examples include our `UserType` enum which possesses great quality of life functionality such as allowing us to query whether a given type is a buyer / seller / privileged and compare types directly with equivalence operations (as enumerated members describe named constant instances) and use these members in switch statements.

*   As numerous transactions are supposed to fail if certain constraints are not met or rules are violated, we've used exceptions to return errors and transaction-failing states back to the transactions that call them, where these exceptions hold contextual information about the situation surrounding the transaction's termination and allow for a convenient way to break out of the transaction partway and handle all of our errors in a uniform, consistent, and semantically obvious format.

*   Noticing that `Inventory` and `StoreFront` possessed a large amount of overlap, we offloaded the bulk of the functionality of both classes to a parent class employing generics called `Catalogue`. This allows us to store either a number of `Game`s, or a number of `Listing`s and not have to implement the functionality once in each.

*   Noticing that the `Transaction`s all represent an action, we decided to implement the transactions using the Command pattern, where the calling class possesses a container of transactions sequentially parsed from the `daily.txt` file and iterates over them calling `execute` on each one which is resolved through dynamic dispatch.

*   As numerous classes need to perform some kind of actions at the end of each `Market` day, we implemented an `EndOfDay` interface which allows for containerisation of these classes into a single collection for batch processing at the end of a day.

*   To maintain the state of the `Market` more accurately than could be done with simple file I/O, we embraced serialization to convert the classes we needed to persist into bytestreams to later be restored.

*   To allow for uniform bespoke error handling, we implemented an `ErrorLogger` which prints the severity of a problem, as well as optional contextual information for what caused the problem to occur and a description of the problem itself.

*   To allow testers to dictate and alternative starting state for our database when the back-end starts, we've included a `DatabaseBuilder` which optionally changes the state of the database to one described if a user passes a valid database construction file name as a runtime argument.

### Database (necessary "bonus" feature)

Our project's backend maintains its state via Java's built-in [Serialization](https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html). As such, all classes that need to maintain their state have `java.io.Serializable` implemented in their hierarchy.

As our project's "database" is a raw bitstream of the state of the market, we encountered an issue in the fact that it would be impossible to add new users barring through shipping with an admin user generated by default. To get over this issue, we've implemented a `DatabaseBuilder` class whose function is to take a user-generated file containing formatted text specifying the desired starting state for the database, and establish the database based on that.

To start the program with the database in a new state, the user must launch the program with a command line argument specifying a valid new database construction file. The way to create a new database with a new `User`(s) is seen below:

*   Declare new `User`:

    To add a user into the new database, the database state construction file takes an argument of the following form:

    ```
    TTUUUUUUUUUUUUUUUCCCCCCCC
    ```

    Where `TT` represents the user's type in the same format as in the assignment specification, `UUUUUUUUUUUUUUU` represents the user's username (15 chars, left-aligned and padded with spaces on the right-hand side), and `CCCCCCCC` represents the amount of credit the user should have as a right-justified, zero-padded (on the left-hand side), non-negative integer count of the pennies / cents the user owns as credit.
    
    For example, to create a new full-standard user called "John Smith" with 340.15 credits, the record would be:
    
    ```
    FSJohn Smith     00034015
    ```

    Dictating the user's games works as follows:

*   Declare the number of games (bought):

    **WARNING: OMIT THIS STEP AND THE NEXT STEP IF THE USER IS SELL-ONLY**

    ```
    <num games bought>
    ```

    This line declares the number of purchased games that the user owns (games that live in the user's inventory rather than the storefront, which houses the games they are selling).

    There is no limit on the number of digits provided, but the number written must be a non-negative integer, and must properly correspond to as many succeeding games will be recorded in the next step. There number should be left-justified with neither spaces nor other superfluous symbols.

    So if we wanted to take our "John Smith" and declare he had 2 games in his inventory of purchased games, our entire construction file so far would look as follows:
    
    ```
    FSJohn Smith     00034015
    2
    ```
    
    Specifying the games the user has bought works as follows:

*   Specify the titles of the games (bought):

    **WARNING: OMIT THIS STEP AND THE PREVIOUS STEP IF THE USER IS SELL-ONLY**

    ```
    IIIIIIIIIIIIIIIIIIIIIIIII
    ```

    Where `IIIIIIIIIIIIIIIIIIIIIIIII` corresponds to the name of a game that the user owns (25 chars, left-aligned and padded with spaces on the right-hand side). There should be as many successive lines of this format as was specified in the number of games declaration. E.g. for "John Smith", who has 2 purchased games, the full constructor file so far might be:
    
    ```
    FSJohn Smith     00034015
    2
    Final Fantasy XII        
    Tales of the Abyss       
    ```

    Where `Final Fantasy XII` and `Tales of the Abyss` are the titles of the purchased games owned by John.

*   Declare the number of games (selling):

    **WARNING: OMIT THIS STEP AND THE NEXT STEP IF THE USER IS BUY-ONLY**

    ```
    <num games selling>
    ```

    This line declares the number of games being sold that the user owns (games that live in the user's storefront rather than the inventory, which houses the games they have bought).

    There is no limit on the number of digits provided, but the number written must be a non-negative integer, and must properly correspond to as many succeeding games will be recorded in the next step. There number should be left-justified with neither spaces nor other superfluous symbols.

    So if we wanted to take our "John Smith" and declare he had 1 game in his storefront of games he was selling, bearing in mind our previous lines, our entire construction file so far would look as follows:
    
    ```
    FSJohn Smith     00034015
    2
    Final Fantasy XII        
    Tales of the Abyss       
    1
    ```
    
    Specifying the games the user is selling works as follows:

*   Specify the titles of the games (selling):

    **WARNING: OMIT THIS STEP AND THE PREVIOUS STEP IF THE USER IS BUY-ONLY**

    ```
    IIIIIIIIIIIIIIIIIIIIIIIIIDD.DDPPPPP
    ```

    Where `IIIIIIIIIIIIIIIIIIIIIIIII` corresponds to the name of a game that the user owns (25 chars, left-aligned and padded with spaces on the right-hand side), `DD.DD` refers to the discount percentage of the game, which should be a non-negative decimal number formatted with a decimal point in between the whole component and the decimal component, and `PPPPP` represents the price that this user is charging for the game as a non-negative integer count of the pennies / cents the game costs.
    
    There should be as many successive lines of this format as was specified in the number of games declaration. E.g. for John, who is selling 1 game, the full constructor file so far might be:
    
    ```
    FSJohn Smith     00034015
    2
    Final Fantasy XII        
    Tales of the Abyss       
    1
    Shining Force Exa        25.1513567
    ```

    Where `Shining Force Exa` is a game being sold by John for 135.67 credits and which is has a discount percentage of 25.15%.

    This is the final format for ensuring that John is a user in the new state we are dictating for the database.

*   Adding more than 1 user:

    Successive users follow the same rules and are placed on immediately successive lines from the last entry describing the previous user. For instance, if we wanted to start our program with the user John Smith seen above, as well as a buyer user called Juan with 0 purchased games and 420.69 credits, a seller user called Raymond with 999,999.99 credits and 2 games for sale ("Dragon Ball Z Budokai 3" for 163.00 credits with a 15.5% optional discount and "Chrono Trigger" for sale for 60.00 credits with no optional discount), as well as another buyer user called Hans with 1 game bought ("Trials of Mana") and 0.06 credits in his account, then the full constructor file would be:

    ```
    FSJohn Smith     00034015
    2
    Final Fantasy XII        
    Tales of the Abyss       
    1
    Shining Force Exa        25.1513567
    BSJuan           00042069
    0
    SSRaymond        99999999
    2
    Dragon Ball Z Budokai 3  15.5016300
    Chrono Trigger           00.0006000
    Hans             00000006
    1
    Trials of Mana           
    ```

#### **NOTE**

*   All lines should immediately succeed their preceding lines without blank lines in-between.
*   If a user has no purchased games, then the field for the games the user owns must explicitly be set to 0. Likewise, if a user has no listings, then the field for the listings the user has for sale must be explicitly set to 0.
*   Buy-only users should have neither a number of listings record, nor any listings recorded. Likewie, sell-only users should have neither a number of games record, nor any games recorded.
*   The decimal point must be in the middle of the whole component and decimal component of a discount. If a discount is a whole-number, the right-hand side should contain zeroes.
*   The new database state construction file describes the state the database should be in the next time the backend is run, and in order to have it apply for the next pass of the back-end, one should pass the back-end the filename for said file as a command-line argument on the desired pass.


## Front-end (Bonus Feature)
For a video demo on the front end pipeline, [click here](https://www.youtube.com/watch?v=EJNtig_sR0I).
This project features a front end which is able to produce daily tarnsactions files to be interpreted by the backend. The source code of the front-end is located in the folder "VaportFrontEnd", which is a C# XAML project. The executable is located in the folder "Front End Executable", named "VaportFrontEnd.exe". You will not need to move any files into or out of any directories for this pipeline. The general pipeline of the front end is as follows:
- Initially, you must modify the market_builder.txt file to include one or more accounts.
- Then, you run the back-end with a command-line argument which is the name of the file "market_builder.txt".
    - This action outputs the initial state of the market so that we can have accounts in the system. All the users and their info that the front end requires is outputted into users.json.
- After that, you may run the front end executable, and login with one of the existing accounts that were made through market_builder.txt.
- Make whatever transactions you desire through the front end. Everytime you logout, the daily transaction file is appended to with the transactions you made. (You can logout and login multiple times in the same session, and the daily.txt will include all the transactions for that day)
- Once the daily.txt file is populated with transactions, you may run the back end.
    - The back end will generate a new users.json (besides the market.ser file, which is only used by the back end).
- Now that there is a new users.json generated by the back end, you may run the front end once again and see all the changes of the transactions that were able to successfully execute persist. 
    - If a transaction generated by the front end was not completed successfully, such as attempting to deposit more than 1000 credits in one day, you will see an error log in errorlogged.log, and the change will not make it to users.json, which in turn does not show up in the front end.
- Now the loop is complete, and you may repeat however many times you want. (excluding the initial step of using the market_builder.txt file to create the initial accounts using the back end)

Our front-end contains a lot of features, which are all listed below:
- Login
    - Once you open the executable, the user is prompted with a username to login, which only works if you enter a username that exists in the market. This requires you to manually modify the market_builder.txt to create one (or more) admin/non-admin accounts, then run the back-end once initially, which then outputs a users.json file, which the front-end uses to keep track of the current state of the back-end.
- Logout
    - This is when all of the user that was logged in's transactions are appended to the daily.txt file in the root directory.
- Buy
    - You may buy a game through the main page. This includes the required restrictions such as seller accounts not being able to buy games, not being able to buy your own game, not being able to buy a game listed on the same day, etc. Once you buy a game, you will see your list of owned games update right away, in your profile which is accessable through the button on the top of the window. You may also see more information about a game by selecting it in the main page.
- Sell
    - Through the profile, eligible accounts (not buyers) may list a game for sale by inputting the name, price, and discount of the game then clicking the button. Once you list a game, you will see your list of listed games update right away.
- Add credits
    - Through the profile, you may deposit credits into your own account. This takes into account the daily deposit limit (1000 credits) and the max credits on an account (999999.99). Once you add credits, you will see your current credits in the profile update right away.
- Gift game
    - By selecting a game in your listed game OR owned games lists in the profile, you can then enter a username of an existing user into the gift input box and click gift, which will gift them the game selected. This takes into account whether or not you own the game or have it listed, and removes it from your games if it is owned. It also checks for the recipient's inventory, making sure they do not already own the game.
- Create account
    - In the admin panel (which is only accessable when logged into an admin user, through a button that shows up right next to the profile button), you can enter a username and choose an account type from the dropdown, then click the create button which will then add a new user to the market. If successful, you will immediately see the list of all users right under it update.
- Refund
    - In the admin panel, you can enter a username for the refunder, a username for the recipient, and an amount in order to add credits from the refunder to the recipient. By selecting a user from the list of all users in the admin panel, info about their account will be displayed where you can see their balance update after a refund right away.



## Data Summary Webpage (Bonus Bonus Feature)
This project features a webpage which can produce an graphical representation of the financial statistics of the store. It compares the daily statistics to the since creation statistics. This requires the back-end to have run atleast once to produce a stats.txt.

[Webpage finance chart demo](https://www.youtube.com/watch?v=Njx50-kc7C8)

Note: this webpage is completely designed from scratch.

Webpage background image citation:

    R, T. (2020, November 11). [An image of a Sega console]. Retrieved March 30, 2021, from https://images.unsplash.com/photo-1605134550917-5fe8cf25a125?      ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80
    
___
    
    
    
## MarketToJSON.java (back-end class)
This class is responsible for exporting a JSON representation of the current state of the market. The JSON it produces `users.json` which contains information regarding the state of users in the market after the last run of the back-end. This information is meant to be read in by the front-end. but it can be read (unlike the market.ser) to understand the effect of transactions on the market after each run of the back-end. This class requires the external java library `json-simple-1.1.jar` to operate.

    It is called by the market using the market.export() method.
